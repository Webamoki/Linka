using System.Data;
using System.Text.Json;
using Npgsql;
using Webamoki.Linka.Fields;
using Webamoki.Linka.Queries;

namespace Webamoki.Linka.Models;

public abstract class Model
{
    private static readonly Dictionary<Type, string> TableNames = [];

    public static string TableName<T>() where T : Model => TableName(typeof(T));
    private static string TableName(Type type)
    {
        if (TableNames.TryGetValue(type, out var tableName))
            return tableName;
        throw new Exception($"Table name for {type.Name} not set.");
    }
    public string TableName() => TableName(GetType());

    internal FieldIterator GetFieldIterator()
    {
        var info = ModelRegistry.Get(GetType());
        return info.FieldIterator(this);
    }

    public static void SetTableName<T>(string tableName)
    {
        var type = typeof(T);
        if (!TableNames.TryAdd(type, tableName))
            throw new Exception($"Table name for {type.Name} already set.");
    }

    internal void Load<T>(NpgsqlDataReader reader) where T : Model { Load(typeof(T), reader); }
    
    internal void Load(Type type, IDataReader reader)
    {
        var info = ModelRegistry.Get(type);
        var fieldIterator = GetFieldIterator();
        foreach (var (fieldName, field) in fieldIterator.All())
        {
            var value = reader[$"{info.TableName}.{fieldName}"];
            if (value is DBNull) value = null;
            field.LoadValue(value);
        }
    }

    internal void Load(Type type, Dictionary<string, JsonElement> reader)
    {
        var info = ModelRegistry.Get(type);
        var fieldIterator = GetFieldIterator();
        foreach (var (fieldName, field) in fieldIterator.All())
        {
            var jsonElement = reader[$"{info.TableName}.{fieldName}"];
            object? value =  jsonElement.ValueKind switch
            {
                JsonValueKind.String => jsonElement.GetString(),
                JsonValueKind.Number => jsonElement.TryGetInt64(out var l) ? l : jsonElement.GetDouble(),
                JsonValueKind.True => true,
                JsonValueKind.False => false,
                JsonValueKind.Null => null,
                _ => throw new NotSupportedException(
                    $"Unsupported JSON value kind: {jsonElement.ValueKind} for field {fieldName} in model {type.Name}.")
            };
            field.LoadValue(value);
        }
    }

    /// <summary>
    /// Inserts the current model instance into the database.
    /// </summary>
    /// <param name="dbService">The database service to use for the insert operation.</param>
    /// <returns>DatabaseCode indicating the result of the operation.</returns>
    public DatabaseCode Insert(IDbService dbService)
    {
        var modelType = GetType();
        var info = ModelRegistry.Get(modelType);
        var fieldIterator = GetFieldIterator();

        // Validate all fields before inserting
        var validationErrors = new List<string>();
        foreach (var (fieldName, field) in fieldIterator.All())
        {
            if (!field.IsSet)
            {
                if (info.Fields[fieldName].IsRequired)
                {
                    validationErrors.Add($"Field '{fieldName}' is required.");
                }
                continue;
            }
            if (!field.IsValid(out var message))
            {
                validationErrors.Add($"Field '{fieldName}': {message}");
            }
        }

        if (validationErrors.Count > 0)
        {
            throw new InvalidOperationException($"Model validation failed: {string.Join(", ", validationErrors)}");
        }

        // Create insert query
        var insertQuery = new InsertQuery(info.TableName);
        var values = new List<object>();

        // Add columns and values for all set fields
        foreach (var (fieldName, field) in fieldIterator.All())
        {
            // Only include fields that have been set and are not auto-generated primary keys
            if (field.IsSet && !(field.IsPrimary && IsAutoGeneratedField(field)))
            {
                var value = field.ObjectValue();
                if (value is null) continue;
                insertQuery.AddColumn(fieldName);
                
                if (value is Enum)
                    insertQuery.AddValueMarker($"'{value}'::");
                else
                {
                    insertQuery.AddValueMarker();
                    values.Add(value);
                }
            }
        }

        if (values.Count == 0)
        {
            throw new InvalidOperationException("No fields have been set for insertion.");
        }

        insertQuery.AddValues(values);
        return insertQuery.ExecuteTransaction(dbService);
    }

    /// <summary>
    /// Determines if a field is auto-generated (like auto-increment IDs).
    /// Override this method in derived classes to customize auto-generation logic.
    /// </summary>
    /// <param name="field">The field to check.</param>
    /// <returns>True if the field is auto-generated, false otherwise.</returns>
    private bool IsAutoGeneratedField(DbField field)
    {
        // By default, assume primary key fields with no value set are auto-generated
        return field.IsPrimary && !field.IsSet;
    }
}