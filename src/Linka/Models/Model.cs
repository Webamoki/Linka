using System.Data;
using System.Text.Json;
using Npgsql;
using Webamoki.Linka.Queries;

namespace Webamoki.Linka.Models;

public abstract class Model
{
    private static readonly Dictionary<Type, string> TableNames = [];

    public static string TableName<T>() where T : Model => TableName(typeof(T));
    private static string TableName(Type type)
    {
        if (TableNames.TryGetValue(type, out var tableName))
            return tableName;
        throw new Exception($"Table name for {type.Name} not set.");
    }
    public string TableName() => TableName(GetType());
    
    public static void SetTableName<T>(string tableName)
    {
        var type = typeof(T);
        if (!TableNames.TryAdd(type, tableName))
            throw new Exception($"Table name for {type.Name} already set.");
    }

    internal void Load<T>(NpgsqlDataReader reader) where T : Model { Load(typeof(T), reader); }
    
    internal void Load(Type type, IDataReader reader)
    {
        var info = ModelRegistry.Get(type);
        foreach (var (fieldName, fieldGetter) in info.FieldGetters)
        {
            var value = reader[$"{info.TableName}.{fieldName}"];
            if (value is DBNull) value = null;
            var field = fieldGetter(this);
            field.LoadValue(value);
        }
    }

    internal void Load(Type type, Dictionary<string, JsonElement> reader)
    {
        var info = ModelRegistry.Get(type);
        foreach (var (fieldName, fieldGetter) in info.FieldGetters)
        {
            var jsonElement = reader[$"{info.TableName}.{fieldName}"];
            object? value =  jsonElement.ValueKind switch
            {
                JsonValueKind.String => jsonElement.GetString(),
                JsonValueKind.Number => jsonElement.TryGetInt64(out var l) ? l : jsonElement.GetDouble(),
                JsonValueKind.True => true,
                JsonValueKind.False => false,
                JsonValueKind.Null => null,
                _ => throw new NotSupportedException(
                    $"Unsupported JSON value kind: {jsonElement.ValueKind} for field {fieldName} in model {type.Name}.")
            };
            var field = fieldGetter(this);
            field.LoadValue(value);
        }
    }

    /// <summary>
    /// Inserts the current model instance into the database.
    /// </summary>
    /// <param name="dbService">The database service to use for the insert operation.</param>
    /// <returns>DatabaseCode indicating the result of the operation.</returns>
    public DatabaseCode Insert(IDbService dbService)
    {
        var modelType = GetType();
        var info = ModelRegistry.Get(modelType);

        // Validate all fields before inserting
        var validationErrors = new List<string>();
        foreach (var (fieldName, fieldGetter) in info.FieldGetters)
        {
            var field = fieldGetter(this);
            if (!field.IsValid(out var message))
            {
                validationErrors.Add($"Field '{fieldName}': {message}");
            }
        }

        if (validationErrors.Count > 0)
        {
            throw new InvalidOperationException($"Model validation failed: {string.Join(", ", validationErrors)}");
        }

        // Create insert query
        var insertQuery = new InsertQuery(info.TableName);
        var values = new List<object>();

        // Add columns and values for all set fields
        foreach (var (fieldName, fieldGetter) in info.FieldGetters)
        {
            var field = fieldGetter(this);

            // Only include fields that have been set and are not auto-generated primary keys
            if (field.IsSet && !(field.IsPrimary && IsAutoGeneratedField(field)))
            {
                insertQuery.AddColumn(fieldName);
                values.Add(GetFieldValue(field));
            }
        }

        if (values.Count == 0)
        {
            throw new InvalidOperationException("No fields have been set for insertion.");
        }

        insertQuery.AddValues(values);
        return insertQuery.ExecuteTransaction(dbService);
    }

    /// <summary>
    /// Determines if a field is auto-generated (like auto-increment IDs).
    /// Override this method in derived classes to customize auto-generation logic.
    /// </summary>
    /// <param name="field">The field to check.</param>
    /// <returns>True if the field is auto-generated, false otherwise.</returns>
    protected virtual bool IsAutoGeneratedField(Fields.DbField field)
    {
        // By default, assume primary key fields with no value set are auto-generated
        return field.IsPrimary && !field.IsSet;
    }

    /// <summary>
    /// Gets the value from a field for database insertion.
    /// </summary>
    /// <param name="field">The field to get the value from.</param>
    /// <returns>The field value suitable for database insertion.</returns>
    private static object GetFieldValue(Fields.DbField field)
    {
        // Use reflection to get the Value() method from RefDbField<T> or StructDbField<T>
        var fieldType = field.GetType();
        var valueMethod = fieldType.GetMethod("Value");

        if (valueMethod != null)
        {
            var value = valueMethod.Invoke(field, null);
            return value ?? DBNull.Value;
        }

        // Fallback to StringValue() if Value() method is not available
        try
        {
            var stringValue = field.StringValue();
            return string.IsNullOrEmpty(stringValue) ? DBNull.Value : stringValue;
        }
        catch (InvalidOperationException)
        {
            // Field value is null
            return DBNull.Value;
        }
    }
}